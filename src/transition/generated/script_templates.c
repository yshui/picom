// This file is generated by tools/animgen.c from data/animation_presets.conf
// This file is included in git repository for convenience only.
// DO NOT EDIT THIS FILE!

#include <libconfig.h>
#include "../curve.h"
#include "../script.h"
#include "../script_internal.h"
#include "config.h"
#include "utils/misc.h"
static struct script *script_template__disappear(int *output_slots) {
	static const struct instruction instrs[] = {
	    {.type = INST_BRANCH_ONCE, .rel = 59},
	    {.type = INST_LOAD, .slot = 14},
	    {.type = INST_LOAD, .slot = 13},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 15},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_LINEAR},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 13},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 0},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_STORE, .slot = 1},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_STORE, .slot = 2},
	    {.type = INST_LOAD, .slot = 17},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 18},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = -0x1.4cccccccccccep-1,
	                             .bx = 0x1.051eb851eb852p+0,
	                             .cx = 0x1.428f5c28f5c2ap-1,
	                             .ay = -0x1.47ae147ae148p-6,
	                             .by = 0x1.eb851eb851eb8p-1,
	                             .cy = 0x1.eb851eb851ebap-5}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 5},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD, .slot = 5},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_IMM, .imm = 0x1p+1},
	    {.type = INST_OP, .op = OP_DIV},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 3},
	    {.type = INST_LOAD, .slot = 5},
	    {.type = INST_STORE, .slot = 6},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD, .slot = 6},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_IMM, .imm = 0x1p+1},
	    {.type = INST_OP, .op = OP_DIV},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 4},
	    {.type = INST_LOAD, .slot = 5},
	    {.type = INST_STORE, .slot = 7},
	    {.type = INST_LOAD, .slot = 6},
	    {.type = INST_STORE, .slot = 8},
	    {.type = INST_LOAD, .slot = 3},
	    {.type = INST_STORE, .slot = 9},
	    {.type = INST_LOAD, .slot = 4},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_BRANCH_ONCE, .rel = 15},
	    {.type = INST_HALT},
	    {.type = INST_LOAD_CTX, .ctx = 64},
	    {.type = INST_STORE_OVER_NAN, .slot = 13},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 15},
	    {.type = INST_LOAD_CTX, .ctx = 72},
	    {.type = INST_STORE, .slot = 14},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE_OVER_NAN, .slot = 16},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 18},
	    {.type = INST_LOAD_CTX, .ctx = 1073741828},
	    {.type = INST_STORE, .slot = 17},
	    {.type = INST_BRANCH, .rel = -70},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_LOAD, .slot = 15},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_LOAD, .slot = 18},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_HALT},
	};
	struct script *ret = malloc(offsetof(struct script, instrs) + sizeof(instrs));
	ret->len = ARR_SIZE(instrs);
	ret->elapsed_slot = 11;
	ret->n_slots = 19;
	ret->stack_size = 3;
	ret->vars = NULL;
	ret->overrides = NULL;
	memcpy(ret->instrs, instrs, sizeof(instrs));
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("opacity"), .slot = 0, .index = 0};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("blur-opacity"), .slot = 1, .index = 1};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-opacity"), .slot = 2, .index = 2};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-x"), .slot = 3, .index = 3};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-y"), .slot = 4, .index = 4};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("scale-x"), .slot = 5, .index = 5};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("scale-y"), .slot = 6, .index = 6};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-scale-x"), .slot = 7, .index = 7};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-scale-y"), .slot = 8, .index = 8};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-x"), .slot = 9, .index = 9};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-y"), .slot = 10, .index = 10};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("opacity"), .slot = 13};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("scale-x"), .slot = 16};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	output_slots[0] = 3;
	output_slots[1] = 4;
	output_slots[2] = 9;
	output_slots[3] = 10;
	output_slots[4] = 0;
	output_slots[5] = 1;
	output_slots[6] = 2;
	output_slots[7] = 5;
	output_slots[8] = 6;
	output_slots[9] = 7;
	output_slots[10] = 8;
	output_slots[11] = -1;
	output_slots[12] = -1;
	output_slots[13] = -1;
	output_slots[14] = -1;
	output_slots[15] = -1;
	return ret;
}

static bool
win_script_preset__disappear(struct win_script *output, config_setting_t *setting) {
	output->script = script_template__disappear(output->output_indices);
	double knob_duration = 0x1.999999999999ap-3;
	config_setting_lookup_float(setting, "duration", &knob_duration);
	double knob_scale = 0x1.e666666666666p-1;
	config_setting_lookup_float(setting, "scale", &knob_scale);
	struct script_specialization_context spec[] = {
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 0, .value = knob_duration},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 4, .value = knob_scale},
	};
	script_specialize(output->script, spec, ARR_SIZE(spec));
	return true;
}
static struct script *script_template__appear(int *output_slots) {
	static const struct instruction instrs[] = {
	    {.type = INST_BRANCH_ONCE, .rel = 59},
	    {.type = INST_LOAD, .slot = 14},
	    {.type = INST_LOAD, .slot = 13},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 15},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_LINEAR},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 13},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 0},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_STORE, .slot = 1},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_STORE, .slot = 2},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 17},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = -0x1.4cccccccccccep-1,
	                             .bx = 0x1.dc28f5c28f5c3p-1,
	                             .cx = 0x1.70a3d70a3d70bp-1,
	                             .ay = -0x1.47ae147ae14p-6,
	                             .by = -0x1.cccccccccccd4p-1,
	                             .cy = 0x1.eb851eb851ebap+0}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 5},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD, .slot = 5},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_IMM, .imm = 0x1p+1},
	    {.type = INST_OP, .op = OP_DIV},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 3},
	    {.type = INST_LOAD, .slot = 5},
	    {.type = INST_STORE, .slot = 6},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD, .slot = 6},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_IMM, .imm = 0x1p+1},
	    {.type = INST_OP, .op = OP_DIV},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 4},
	    {.type = INST_LOAD, .slot = 5},
	    {.type = INST_STORE, .slot = 7},
	    {.type = INST_LOAD, .slot = 6},
	    {.type = INST_STORE, .slot = 8},
	    {.type = INST_LOAD, .slot = 3},
	    {.type = INST_STORE, .slot = 9},
	    {.type = INST_LOAD, .slot = 4},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_BRANCH_ONCE, .rel = 13},
	    {.type = INST_HALT},
	    {.type = INST_LOAD_CTX, .ctx = 64},
	    {.type = INST_STORE_OVER_NAN, .slot = 13},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 15},
	    {.type = INST_LOAD_CTX, .ctx = 72},
	    {.type = INST_STORE, .slot = 14},
	    {.type = INST_LOAD_CTX, .ctx = 1073741828},
	    {.type = INST_STORE_OVER_NAN, .slot = 16},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 17},
	    {.type = INST_BRANCH, .rel = -68},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_LOAD, .slot = 15},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_LOAD, .slot = 17},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_HALT},
	};
	struct script *ret = malloc(offsetof(struct script, instrs) + sizeof(instrs));
	ret->len = ARR_SIZE(instrs);
	ret->elapsed_slot = 11;
	ret->n_slots = 18;
	ret->stack_size = 3;
	ret->vars = NULL;
	ret->overrides = NULL;
	memcpy(ret->instrs, instrs, sizeof(instrs));
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("opacity"), .slot = 0, .index = 0};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("blur-opacity"), .slot = 1, .index = 1};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-opacity"), .slot = 2, .index = 2};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-x"), .slot = 3, .index = 3};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-y"), .slot = 4, .index = 4};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("scale-x"), .slot = 5, .index = 5};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("scale-y"), .slot = 6, .index = 6};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-scale-x"), .slot = 7, .index = 7};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-scale-y"), .slot = 8, .index = 8};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-x"), .slot = 9, .index = 9};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-y"), .slot = 10, .index = 10};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("opacity"), .slot = 13};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("scale-x"), .slot = 16};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	output_slots[0] = 3;
	output_slots[1] = 4;
	output_slots[2] = 9;
	output_slots[3] = 10;
	output_slots[4] = 0;
	output_slots[5] = 1;
	output_slots[6] = 2;
	output_slots[7] = 5;
	output_slots[8] = 6;
	output_slots[9] = 7;
	output_slots[10] = 8;
	output_slots[11] = -1;
	output_slots[12] = -1;
	output_slots[13] = -1;
	output_slots[14] = -1;
	output_slots[15] = -1;
	return ret;
}

static bool win_script_preset__appear(struct win_script *output, config_setting_t *setting) {
	output->script = script_template__appear(output->output_indices);
	double knob_duration = 0x1.999999999999ap-3;
	config_setting_lookup_float(setting, "duration", &knob_duration);
	double knob_scale = 0x1.e666666666666p-1;
	config_setting_lookup_float(setting, "scale", &knob_scale);
	struct script_specialization_context spec[] = {
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 0, .value = knob_duration},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 4, .value = knob_scale},
	};
	script_specialize(output->script, spec, ARR_SIZE(spec));
	return true;
}
static struct script *script_template__slide_out(int *output_slots) {
	static const struct instruction instrs[] = {
	    {.type = INST_BRANCH_ONCE, .rel = 42},
	    {.type = INST_LOAD, .slot = 15},
	    {.type = INST_LOAD, .slot = 14},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = -0x1.4cccccccccccep-1,
	                             .bx = 0x1.051eb851eb852p+0,
	                             .cx = 0x1.428f5c28f5c2ap-1,
	                             .ay = -0x1.47ae147ae148p-6,
	                             .by = 0x1.eb851eb851eb8p-1,
	                             .cy = 0x1.eb851eb851ebap-5}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 14},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 0},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 1},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 2},
	    {.type = INST_LOAD, .slot = 1},
	    {.type = INST_STORE, .slot = 3},
	    {.type = INST_LOAD, .slot = 2},
	    {.type = INST_STORE, .slot = 4},
	    {.type = INST_LOAD_CTX, .ctx = 0},
	    {.type = INST_STORE, .slot = 5},
	    {.type = INST_LOAD_CTX, .ctx = 8},
	    {.type = INST_STORE, .slot = 6},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_STORE, .slot = 7},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_STORE, .slot = 8},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_STORE, .slot = 11},
	    {.type = INST_BRANCH_ONCE, .rel = 17},
	    {.type = INST_HALT},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE_OVER_NAN, .slot = 14},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 16},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_LOAD_CTX, .ctx = 1073741828},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_LOAD_CTX, .ctx = 1073741832},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 15},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE, .slot = 9},
	    {.type = INST_BRANCH, .rel = -55},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE, .slot = 13},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 13},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 13},
	    {.type = INST_HALT},
	};
	struct script *ret = malloc(offsetof(struct script, instrs) + sizeof(instrs));
	ret->len = ARR_SIZE(instrs);
	ret->elapsed_slot = 12;
	ret->n_slots = 17;
	ret->stack_size = 3;
	ret->vars = NULL;
	ret->overrides = NULL;
	memcpy(ret->instrs, instrs, sizeof(instrs));
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("v-timing"), .slot = 0, .index = 0};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-x"), .slot = 1, .index = 1};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-y"), .slot = 2, .index = 2};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-x"), .slot = 3, .index = 3};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-y"), .slot = 4, .index = 4};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-x"), .slot = 5, .index = 5};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-y"), .slot = 6, .index = 6};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-width"), .slot = 7, .index = 7};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-height"), .slot = 8, .index = 8};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("opacity"), .slot = 9, .index = 9};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("blur-opacity"), .slot = 10, .index = 10};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-opacity"), .slot = 11, .index = 11};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("v-timing"), .slot = 14};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	output_slots[0] = 1;
	output_slots[1] = 2;
	output_slots[2] = 3;
	output_slots[3] = 4;
	output_slots[4] = 9;
	output_slots[5] = 10;
	output_slots[6] = 11;
	output_slots[7] = -1;
	output_slots[8] = -1;
	output_slots[9] = -1;
	output_slots[10] = -1;
	output_slots[11] = 5;
	output_slots[12] = 6;
	output_slots[13] = 7;
	output_slots[14] = 8;
	output_slots[15] = -1;
	return ret;
}

static bool
win_script_preset__slide_out(struct win_script *output, config_setting_t *setting) {
	output->script = script_template__slide_out(output->output_indices);
	double knob_duration = 0x1.999999999999ap-3;
	config_setting_lookup_float(setting, "duration", &knob_duration);
	const char *knob_direction = "left";
	config_setting_lookup_string(setting, "direction", &knob_direction);
	double placeholder1_direction;
	double placeholder2_direction;
	double placeholder3_direction;
	if (strcmp(knob_direction, "up") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = -0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "down") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = 0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "left") == 0) {
		placeholder1_direction = -0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else if (strcmp(knob_direction, "right") == 0) {
		placeholder1_direction = 0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else {
		log_error("Invalid choice \"%s\" for option \"direction\". Line %d.",
		          knob_direction,
		          config_setting_source_line(
		              config_setting_get_member(setting, "direction")));
		log_error("    Valid ones are: \"up\", \"down\", \"left\", \"right\"");
		script_free(output->script);
		output->script = NULL;
		return false;
	}
	struct script_specialization_context spec[] = {
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 0, .value = knob_duration},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 4, .value = placeholder1_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 8, .value = placeholder2_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 12, .value = placeholder3_direction},
	};
	script_specialize(output->script, spec, ARR_SIZE(spec));
	return true;
}
static struct script *script_template__slide_in(int *output_slots) {
	static const struct instruction instrs[] = {
	    {.type = INST_BRANCH_ONCE, .rel = 38},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = -0x1.4cccccccccccep-1,
	                             .bx = 0x1.dc28f5c28f5c3p-1,
	                             .cx = 0x1.70a3d70a3d70bp-1,
	                             .ay = -0x1.47ae147ae14p-6,
	                             .by = -0x1.cccccccccccd4p-1,
	                             .cy = 0x1.eb851eb851ebap+0}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 0},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 1},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 2},
	    {.type = INST_LOAD, .slot = 1},
	    {.type = INST_STORE, .slot = 3},
	    {.type = INST_LOAD, .slot = 2},
	    {.type = INST_STORE, .slot = 4},
	    {.type = INST_LOAD_CTX, .ctx = 0},
	    {.type = INST_STORE, .slot = 5},
	    {.type = INST_LOAD_CTX, .ctx = 8},
	    {.type = INST_STORE, .slot = 6},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_STORE, .slot = 7},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_STORE, .slot = 8},
	    {.type = INST_BRANCH_ONCE, .rel = 13},
	    {.type = INST_HALT},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_LOAD_CTX, .ctx = 1073741828},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_LOAD_CTX, .ctx = 1073741832},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE_OVER_NAN, .slot = 11},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_BRANCH, .rel = -47},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_HALT},
	};
	struct script *ret = malloc(offsetof(struct script, instrs) + sizeof(instrs));
	ret->len = ARR_SIZE(instrs);
	ret->elapsed_slot = 9;
	ret->n_slots = 13;
	ret->stack_size = 3;
	ret->vars = NULL;
	ret->overrides = NULL;
	memcpy(ret->instrs, instrs, sizeof(instrs));
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("v-timing"), .slot = 0, .index = 0};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-x"), .slot = 1, .index = 1};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-y"), .slot = 2, .index = 2};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-x"), .slot = 3, .index = 3};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-y"), .slot = 4, .index = 4};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-x"), .slot = 5, .index = 5};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-y"), .slot = 6, .index = 6};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-width"), .slot = 7, .index = 7};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("crop-height"), .slot = 8, .index = 8};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("v-timing"), .slot = 11};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	output_slots[0] = 1;
	output_slots[1] = 2;
	output_slots[2] = 3;
	output_slots[3] = 4;
	output_slots[4] = -1;
	output_slots[5] = -1;
	output_slots[6] = -1;
	output_slots[7] = -1;
	output_slots[8] = -1;
	output_slots[9] = -1;
	output_slots[10] = -1;
	output_slots[11] = 5;
	output_slots[12] = 6;
	output_slots[13] = 7;
	output_slots[14] = 8;
	output_slots[15] = -1;
	return ret;
}

static bool win_script_preset__slide_in(struct win_script *output, config_setting_t *setting) {
	output->script = script_template__slide_in(output->output_indices);
	double knob_duration = 0x1.999999999999ap-3;
	config_setting_lookup_float(setting, "duration", &knob_duration);
	const char *knob_direction = "left";
	config_setting_lookup_string(setting, "direction", &knob_direction);
	double placeholder1_direction;
	double placeholder2_direction;
	double placeholder3_direction;
	if (strcmp(knob_direction, "up") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = -0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "down") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = 0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "left") == 0) {
		placeholder1_direction = -0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else if (strcmp(knob_direction, "right") == 0) {
		placeholder1_direction = 0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else {
		log_error("Invalid choice \"%s\" for option \"direction\". Line %d.",
		          knob_direction,
		          config_setting_source_line(
		              config_setting_get_member(setting, "direction")));
		log_error("    Valid ones are: \"up\", \"down\", \"left\", \"right\"");
		script_free(output->script);
		output->script = NULL;
		return false;
	}
	struct script_specialization_context spec[] = {
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 0, .value = knob_duration},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 4, .value = placeholder1_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 8, .value = placeholder2_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 12, .value = placeholder3_direction},
	};
	script_specialize(output->script, spec, ARR_SIZE(spec));
	return true;
}
static struct script *script_template__fly_out(int *output_slots) {
	static const struct instruction instrs[] = {
	    {.type = INST_BRANCH_ONCE, .rel = 30},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 8},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = -0x1.d70a3d70a3d75p-1,
	                             .bx = 0x1.c51eb851eb854p+0,
	                             .cx = 0x1.3333333333334p-3,
	                             .ay = 0x1.2666666666666p+0,
	                             .by = -0x1.3333333333334p-3,
	                             .cy = 0x0p+0}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 0},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 1},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 2},
	    {.type = INST_LOAD, .slot = 1},
	    {.type = INST_STORE, .slot = 3},
	    {.type = INST_LOAD, .slot = 2},
	    {.type = INST_STORE, .slot = 4},
	    {.type = INST_BRANCH_ONCE, .rel = 25},
	    {.type = INST_HALT},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE_OVER_NAN, .slot = 10},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_LOAD_CTX, .ctx = 8},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD_CTX, .ctx = 1073741832},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_LOAD_CTX, .ctx = 0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD_CTX, .ctx = 1073741828},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 11},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE, .slot = 5},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE, .slot = 6},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE, .slot = 7},
	    {.type = INST_BRANCH, .rel = -51},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE, .slot = 9},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 9},
	    {.type = INST_HALT},
	};
	struct script *ret = malloc(offsetof(struct script, instrs) + sizeof(instrs));
	ret->len = ARR_SIZE(instrs);
	ret->elapsed_slot = 8;
	ret->n_slots = 13;
	ret->stack_size = 3;
	ret->vars = NULL;
	ret->overrides = NULL;
	memcpy(ret->instrs, instrs, sizeof(instrs));
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("v-timing"), .slot = 0, .index = 0};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-x"), .slot = 1, .index = 1};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-y"), .slot = 2, .index = 2};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-x"), .slot = 3, .index = 3};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-y"), .slot = 4, .index = 4};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("opacity"), .slot = 5, .index = 5};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-opacity"), .slot = 6, .index = 6};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("blur-opacity"), .slot = 7, .index = 7};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("v-timing"), .slot = 10};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	output_slots[0] = 1;
	output_slots[1] = 2;
	output_slots[2] = 3;
	output_slots[3] = 4;
	output_slots[4] = 5;
	output_slots[5] = 7;
	output_slots[6] = 6;
	output_slots[7] = -1;
	output_slots[8] = -1;
	output_slots[9] = -1;
	output_slots[10] = -1;
	output_slots[11] = -1;
	output_slots[12] = -1;
	output_slots[13] = -1;
	output_slots[14] = -1;
	output_slots[15] = -1;
	return ret;
}

static bool win_script_preset__fly_out(struct win_script *output, config_setting_t *setting) {
	output->script = script_template__fly_out(output->output_indices);
	double knob_duration = 0x1.999999999999ap-3;
	config_setting_lookup_float(setting, "duration", &knob_duration);
	const char *knob_direction = "up";
	config_setting_lookup_string(setting, "direction", &knob_direction);
	double placeholder1_direction;
	double placeholder2_direction;
	double placeholder3_direction;
	if (strcmp(knob_direction, "up") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = -0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "down") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = 0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "left") == 0) {
		placeholder1_direction = -0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else if (strcmp(knob_direction, "right") == 0) {
		placeholder1_direction = 0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else {
		log_error("Invalid choice \"%s\" for option \"direction\". Line %d.",
		          knob_direction,
		          config_setting_source_line(
		              config_setting_get_member(setting, "direction")));
		log_error("    Valid ones are: \"up\", \"down\", \"left\", \"right\"");
		script_free(output->script);
		output->script = NULL;
		return false;
	}
	struct script_specialization_context spec[] = {
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 0, .value = knob_duration},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 4, .value = placeholder1_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 8, .value = placeholder2_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 12, .value = placeholder3_direction},
	};
	script_specialize(output->script, spec, ARR_SIZE(spec));
	return true;
}
static struct script *script_template__fly_in(int *output_slots) {
	static const struct instruction instrs[] = {
	    {.type = INST_BRANCH_ONCE, .rel = 30},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 8},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = -0x1.0f5c28f5c28f8p-1,
	                             .bx = 0x1.051eb851eb853p+0,
	                             .cx = 0x1.051eb851eb852p-1,
	                             .ay = -0x1.47ae147ae146p-4,
	                             .by = -0x1.dc28f5c28f5ccp-1,
	                             .cy = 0x1.0147ae147ae16p+1}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 0},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 1},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD_CTX, .ctx = 1073741836},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_STORE, .slot = 2},
	    {.type = INST_LOAD, .slot = 1},
	    {.type = INST_STORE, .slot = 3},
	    {.type = INST_LOAD, .slot = 2},
	    {.type = INST_STORE, .slot = 4},
	    {.type = INST_BRANCH_ONCE, .rel = 16},
	    {.type = INST_HALT},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_OP, .op = OP_NEG},
	    {.type = INST_LOAD_CTX, .ctx = 8},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_STORE_OVER_NAN, .slot = 10},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 11},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE, .slot = 5},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE, .slot = 6},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE, .slot = 7},
	    {.type = INST_BRANCH, .rel = -42},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE, .slot = 9},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 9},
	    {.type = INST_HALT},
	};
	struct script *ret = malloc(offsetof(struct script, instrs) + sizeof(instrs));
	ret->len = ARR_SIZE(instrs);
	ret->elapsed_slot = 8;
	ret->n_slots = 12;
	ret->stack_size = 3;
	ret->vars = NULL;
	ret->overrides = NULL;
	memcpy(ret->instrs, instrs, sizeof(instrs));
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("v-timing"), .slot = 0, .index = 0};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-x"), .slot = 1, .index = 1};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-y"), .slot = 2, .index = 2};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-x"), .slot = 3, .index = 3};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-y"), .slot = 4, .index = 4};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("opacity"), .slot = 5, .index = 5};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-opacity"), .slot = 6, .index = 6};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("blur-opacity"), .slot = 7, .index = 7};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("v-timing"), .slot = 10};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	output_slots[0] = 1;
	output_slots[1] = 2;
	output_slots[2] = 3;
	output_slots[3] = 4;
	output_slots[4] = 5;
	output_slots[5] = 7;
	output_slots[6] = 6;
	output_slots[7] = -1;
	output_slots[8] = -1;
	output_slots[9] = -1;
	output_slots[10] = -1;
	output_slots[11] = -1;
	output_slots[12] = -1;
	output_slots[13] = -1;
	output_slots[14] = -1;
	output_slots[15] = -1;
	return ret;
}

static bool win_script_preset__fly_in(struct win_script *output, config_setting_t *setting) {
	output->script = script_template__fly_in(output->output_indices);
	double knob_duration = 0x1.999999999999ap-3;
	config_setting_lookup_float(setting, "duration", &knob_duration);
	const char *knob_direction = "up";
	config_setting_lookup_string(setting, "direction", &knob_direction);
	double placeholder1_direction;
	double placeholder2_direction;
	double placeholder3_direction;
	if (strcmp(knob_direction, "up") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = -0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "down") == 0) {
		placeholder1_direction = 0x0p+0;
		placeholder2_direction = 0x1p+0;
		placeholder3_direction = 0x0p+0;
	} else if (strcmp(knob_direction, "left") == 0) {
		placeholder1_direction = -0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else if (strcmp(knob_direction, "right") == 0) {
		placeholder1_direction = 0x1p+0;
		placeholder2_direction = 0x0p+0;
		placeholder3_direction = 0x1p+0;
	} else {
		log_error("Invalid choice \"%s\" for option \"direction\". Line %d.",
		          knob_direction,
		          config_setting_source_line(
		              config_setting_get_member(setting, "direction")));
		log_error("    Valid ones are: \"up\", \"down\", \"left\", \"right\"");
		script_free(output->script);
		output->script = NULL;
		return false;
	}
	struct script_specialization_context spec[] = {
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 0, .value = knob_duration},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 4, .value = placeholder1_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 8, .value = placeholder2_direction},
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 12, .value = placeholder3_direction},
	};
	script_specialize(output->script, spec, ARR_SIZE(spec));
	return true;
}
static struct script *script_template__geometry_change(int *output_slots) {
	static const struct instruction instrs[] = {
	    {.type = INST_BRANCH_ONCE, .rel = 76},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = 0x1.35c28f5c28f5cp+0,
	                             .bx = -0x1.ae147ae147ae2p-2,
	                             .cx = 0x1.ae147ae147ae2p-3,
	                             .ay = -0x1.999999999996p-5,
	                             .by = -0x1.cccccccccccd4p-1,
	                             .cy = 0x1.f333333333335p+0}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 11},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 0},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_LOAD, .slot = 13},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 14},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = 0x1.35c28f5c28f5cp+0,
	                             .bx = -0x1.ae147ae147ae2p-2,
	                             .cx = 0x1.ae147ae147ae2p-3,
	                             .ay = -0x1.999999999996p-5,
	                             .by = -0x1.cccccccccccd4p-1,
	                             .cy = 0x1.f333333333335p+0}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 13},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 1},
	    {.type = INST_LOAD, .slot = 0},
	    {.type = INST_STORE, .slot = 2},
	    {.type = INST_LOAD, .slot = 1},
	    {.type = INST_STORE, .slot = 3},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_LOAD, .slot = 15},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = 0x1.35c28f5c28f5cp+0,
	                             .bx = -0x1.ae147ae147ae2p-2,
	                             .cx = 0x1.ae147ae147ae2p-3,
	                             .ay = -0x1.999999999996p-5,
	                             .by = -0x1.cccccccccccd4p-1,
	                             .cy = 0x1.f333333333335p+0}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 15},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 4},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_LOAD, .slot = 17},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 18},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_CUBIC_BEZIER,
	                  .bezier = {.ax = 0x1.35c28f5c28f5cp+0,
	                             .bx = -0x1.ae147ae147ae2p-2,
	                             .cx = 0x1.ae147ae147ae2p-3,
	                             .ay = -0x1.999999999996p-5,
	                             .by = -0x1.cccccccccccd4p-1,
	                             .cy = 0x1.f333333333335p+0}},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 17},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 5},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_LOAD, .slot = 19},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 9},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_LOAD, .slot = 20},
	    {.type = INST_OP, .op = OP_DIV},
	    {
	        .type = INST_CURVE,
	        .curve = {.type = CURVE_LINEAR},
	    },
	    {.type = INST_OP, .op = OP_MUL},
	    {.type = INST_LOAD, .slot = 19},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_STORE, .slot = 6},
	    {.type = INST_LOAD, .slot = 4},
	    {.type = INST_STORE, .slot = 7},
	    {.type = INST_LOAD, .slot = 5},
	    {.type = INST_STORE, .slot = 8},
	    {.type = INST_BRANCH_ONCE, .rel = 31},
	    {.type = INST_HALT},
	    {.type = INST_LOAD_CTX, .ctx = 48},
	    {.type = INST_LOAD_CTX, .ctx = 16},
	    {.type = INST_OP, .op = OP_DIV},
	    {.type = INST_STORE_OVER_NAN, .slot = 11},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 12},
	    {.type = INST_LOAD_CTX, .ctx = 56},
	    {.type = INST_LOAD_CTX, .ctx = 24},
	    {.type = INST_OP, .op = OP_DIV},
	    {.type = INST_STORE_OVER_NAN, .slot = 13},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 14},
	    {.type = INST_LOAD_CTX, .ctx = 32},
	    {.type = INST_LOAD_CTX, .ctx = 0},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_STORE_OVER_NAN, .slot = 15},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 16},
	    {.type = INST_LOAD_CTX, .ctx = 40},
	    {.type = INST_LOAD_CTX, .ctx = 8},
	    {.type = INST_OP, .op = OP_SUB},
	    {.type = INST_STORE_OVER_NAN, .slot = 17},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 18},
	    {.type = INST_IMM, .imm = 0x1p+0},
	    {.type = INST_STORE_OVER_NAN, .slot = 19},
	    {.type = INST_LOAD_CTX, .ctx = 1073741824},
	    {.type = INST_STORE, .slot = 20},
	    {.type = INST_BRANCH, .rel = -103},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_LOAD, .slot = 12},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_LOAD, .slot = 14},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_LOAD, .slot = 16},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_LOAD, .slot = 18},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_LOAD, .slot = 20},
	    {.type = INST_IMM, .imm = 0x0p+0},
	    {.type = INST_OP, .op = OP_ADD},
	    {.type = INST_LOAD, .slot = 10},
	    {.type = INST_OP, .op = OP_MAX},
	    {.type = INST_STORE, .slot = 10},
	    {.type = INST_HALT},
	};
	struct script *ret = malloc(offsetof(struct script, instrs) + sizeof(instrs));
	ret->len = ARR_SIZE(instrs);
	ret->elapsed_slot = 9;
	ret->n_slots = 21;
	ret->stack_size = 3;
	ret->vars = NULL;
	ret->overrides = NULL;
	memcpy(ret->instrs, instrs, sizeof(instrs));
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("scale-x"), .slot = 0, .index = 0};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("scale-y"), .slot = 1, .index = 1};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-scale-x"), .slot = 2, .index = 2};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-scale-y"), .slot = 3, .index = 3};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-x"), .slot = 4, .index = 4};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("offset-y"), .slot = 5, .index = 5};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("saved-image-blend"), .slot = 6, .index = 6};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-x"), .slot = 7, .index = 7};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct variable_allocation *var = malloc(sizeof(*var));
		*var = (struct variable_allocation){
		    .name = strdup("shadow-offset-y"), .slot = 8, .index = 8};
		HASH_ADD_STR(ret->vars, name, var);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("scale-x"), .slot = 11};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("scale-y"), .slot = 13};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("offset-x"), .slot = 15};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("offset-y"), .slot = 17};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	{
		struct overridable_slot *override = malloc(sizeof(*override));
		*override = (struct overridable_slot){.name = strdup("saved-image-blend"),
		                                      .slot = 19};
		HASH_ADD_STR(ret->overrides, name, override);
	}
	output_slots[0] = 4;
	output_slots[1] = 5;
	output_slots[2] = 7;
	output_slots[3] = 8;
	output_slots[4] = -1;
	output_slots[5] = -1;
	output_slots[6] = -1;
	output_slots[7] = 0;
	output_slots[8] = 1;
	output_slots[9] = 2;
	output_slots[10] = 3;
	output_slots[11] = -1;
	output_slots[12] = -1;
	output_slots[13] = -1;
	output_slots[14] = -1;
	output_slots[15] = 6;
	return ret;
}

static bool
win_script_preset__geometry_change(struct win_script *output, config_setting_t *setting) {
	output->script = script_template__geometry_change(output->output_indices);
	double knob_duration = 0x1.999999999999ap-2;
	config_setting_lookup_float(setting, "duration", &knob_duration);
	struct script_specialization_context spec[] = {
	    {.offset = SCRIPT_CTX_PLACEHOLDER_BASE + 0, .value = knob_duration},
	};
	script_specialize(output->script, spec, ARR_SIZE(spec));
	return true;
}
struct {
	const char *name;
	bool (*func)(struct win_script *output, config_setting_t *setting);
} win_script_presets[] = {
    {"disappear", win_script_preset__disappear},
    {"appear", win_script_preset__appear},
    {"slide-out", win_script_preset__slide_out},
    {"slide-in", win_script_preset__slide_in},
    {"fly-out", win_script_preset__fly_out},
    {"fly-in", win_script_preset__fly_in},
    {"geometry-change", win_script_preset__geometry_change},
    {NULL, NULL},
};
